# See LICENSE for details

import os
import sys
import pluggy
import shutil
import random
import re
import datetime
import pytest
import glob

from river_core.log import logger
from river_core.utils import *

dut_hookimpl = pluggy.HookimplMarker('dut')

class azurite_questa_plugin(object):
    '''
        Plugin to set azurite as the target
    '''

    @dut_hookimpl
    def init(self, ini_config, test_list, work_dir, coverage_config,
             plugin_path):
        self.name = 'azurite_questa'
        logger.info('Pre Compile Stage')

        self.src_dir = os.path.abspath(ini_config['azurite_root'])
        if 'stop_on_failure' in ini_config:
            self.stop_on_failure = ini_config['stop_on_failure']
        else:
            self.stop_on_failure = False

        self.top_module = ini_config['top_module']

        self.plugin_path = plugin_path + '/'

        if coverage_config is not None:
            self.coverage = True
            self.coverage_func = bool(
                distutils.utils.strbool(coverage_config['functional']))
            self.coverage_struct = bool(
                distutils.utils.strbool(coverage_config['code']))
        else:
            self.coverage = False
            self.coverage_func = bool(
                distutils.util.strtobool((coverage_config['functional'])))
            self.coverage_struct = bool(
                distutils.util.strtobool((coverage_config['code'])))
            
        if shutil.which('bsc') is None:
            logger.error('bsc not available in $PATH')
            raise SystemExit
        else:
            self.bsc_path = shutil.which("bsc")[:-7]

        #Get plugin specific config from ini
        self.jobs = ini_config['jobs']
        self.filter = ini_config['filter']
        self.riscv_isa = ini_config['isa']
        if '64' in self.riscv_isa:
            self.xlen = 64
        else:
            self.xlen = 32
        if 'D' in self.riscv_isa:
            self.flen = 64
        elif 'F' in self.riscv_isa:
            self.flen = 32
        else:
            self.flen = self.xlen

        self.elf = 'dut.elf'

        self.elf2hex_cmd = 'elf2hex {0} 4194304 dut.elf 2147483648 > code.mem && '.format(
            str(int(self.xlen/8)))
        self.objdump_cmd = 'riscv{0}-unknown-elf-objdump -D dut.elf > dut.disass &&'.format(
            self.xlen)
        self.sim_cmd = './azurite_core'
        self.sim_args = '+rtldump > /dev/null'

        self.work_dir = os.path.abspath(work_dir) + '/'

        self.sim_path = self.work_dir + self.name
        os.makedirs(self.sim_path, exist_ok=True)

        self.test_list = load_yaml(test_list)

        self.json_dir = self.work_dir + '/.json/'

        # Check if dir exists
        if (os.path.isdir(self.json_dir)):
            logger.debug(self.json_dir + ' Directory exists')
        else:
            os.makedirs(self.json_dir)

        if not os.path.exists(self.sim_path):
            logger.error('Sim binary Path ' + self.sim_path + ' does not exist')
            raise SystemExit

        '''
        elf2hex--> is used to convert elf files to hex files which can be read by Verilog readmemh
        vlib-->is a command used to create a new library within the QuestaSim simulation environment
        vlog--> command is used to compile and analyze Verilog source code or design files.
        vsim-->command used to launch the QuestaSim simulator and start a simulation session
        vcover--> command in QuestaSim that is used to generate code coverage reports
        '''
        check_utils = ['elf2hex', 'vlib', 'vlog', 'vsim', 'vcover']

        # for loop to check if the utility is present in the system, if not found raise SystemExit
        for exe in check_utils:
            if shutil.which(exe) is None:
                logger.error(exe + ' utility not found in $PATH')
                raise SystemExit

        for path in self.src_dir:#correction_req
            if not os.path.exists(path):
                logger.error('Source code ' + path + ' does not exist')
                raise SystemExit
       
        #logger.debug('fix path in tb_top')
        #tbfile = open(self.plugin_path + self.name + '_plugin/sv_top/tb_top.sv',
        #              'r')
        #tbfile_read = tbfile.read()
        #tbfile_read = tbfile_read.replace(
        #    'plugin_path', self.plugin_path + self.name + '_plugin/')
        #tbfile.close()
        #tbfile = open(self.plugin_path + self.name + '_plugin/sv_top/tb_top.sv',
        #              'w')
        #tbfile.write(tbfile_read)
        #tbfile.close()

        orig_path = os.getcwd()
        logger.info("Build using msim")
        os.chdir(self.sim_path)

        vlib_cmd = 'vlib work'

        # path to the directory containing SV files generated by utg
        generators = []

        for key, value in self.test_list.items():
            generators.append(self.test_list[key]['generator'])
            if ('uatg' in set(generators)) and (len(set(generators)) > 1):
                logger.critical(
                    'Running tests generated by UATG with other tests generated by other generators is \'currently\' not supported'
                )
                logger.critical(
                    'Generate and run the tests from UATG separately')
                try:
                    raise SystemExit('Exiting as two generators were used')
                except SystemExit as e:
                    print('Not Exited')
            else:
                pass

        sv_dir = ''
        for key, value in self.test_list.items():
            if self.test_list[key]['generator'] == 'uatg':
                sv_dir = os.path.abspath(
                    os.path.join(self.test_list[key]['work_dir'], '../..'))
                break
            else:
                sv_dir = self.plugin_path + self.name + '_plugin'
                break

        vlog_cmd = 'vlog -cover bcefst -sv -work work +libext+.v+.vqm \
                    -y {1}\
                   +define+TOP={0} {2}/sv_top/tb_top.sv {3}/lib/Verilog/main.v ' \
                   .format(self.top_module, self.src_dir, sv_dir, self.bsc_path)#correction_req

        vsim_cmd = 'vsim -quiet -novopt +rtldump -lib work -c main'

        if self.coverage_struct and self.coverage_func:
            logger.info("Structural and functional coverage are enabled")
            vlog_cmd = vlog_cmd
            for test, attr in self.test_list.items():
                with open('azurite_core_{0}'.format(test), 'w') as f:
                    f.write(
                        vsim_cmd + ' -coverage ' + ' -cvgperinstance ' +
                        ' -assertcover ' + ' -voptargs="+cover=bcfst" ' +
                        ' -do "coverage save -cvg -assert -onexit -codeAll ' +
                        test + '.ucdb;run -all; quit" ')
                    #f.write('vcover report -hidecvginsts -details -cvg -code bcefst -assert -html -htmldir ./coverage/report_html/ test_cov.ucdb')
        elif self.coverage_struct and not self.coverage_func:
            logger.info("Structural coverage is enabled")
            vlog_cmd = vlog_cmd + ' -cover bcefst'
            for test, attr in self.test_list.items():
                with open('azurite_core_{0}'.format(test), 'w') as f:
                    f.write(vsim_cmd + ' -coverage' +
                            ' -voptargs="+cover=bcfest"' +
                            ' -do "coverage save -onexit -codeAll ' + test +
                            '.ucdb;run -all; quit"')
                    #f.write('vcover report -details  -code bcefst -html -htmldir ./coverage/report_html/ test_cov.ucdb')
        elif self.coverage_func and not self.coverage_struct:
            logger.info("functional coverage is enabled")
            vlog_cmd = vlog_cmd.format('')
            for test, attr in self.test_list.items():
                with open('azurite_core_{0}'.format(test), 'w') as f:
                    f.write(vsim_cmd + ' -cvgperinstance' + ' -assertcover' +
                            ' -do "coverage save -cvg -assert -onexit ' + test +
                            '.ucdb;run -all; quit"')
            # f.write('vcover report -hidecvginsts -details -cvg  -assert -html -htmldir ./coverage/report_html/ test_cov.ucdb')
        else:
            logger.info("coverage is disabled")
            vlog_cmd = vlog_cmd.format('')
            for test, attr in self.test_list.items():
                with open('azurite_core_{0}'.format(test), 'w') as f:
                    f.write(vsim_cmd + ' -do "coverage save -onexit ' + test +
                            '.ucdb;run -all; quit"')
                    #f.write('vcover report -details -html -htmldir ./coverage/report_html/ test_cov.ucdb')
            #if not self.coverage_func:
            #ncelab_cmd = ncelab_cmd + ' -covdut mkccore_axi4 '

        # sys_command is a wrapper function to run shell commands with a timeout
        sys_command(vlib_cmd, 500) 
        sys_command(vlog_cmd, 500)

        logger.info('Renaming Binary')
        for test, attr in self.test_list.items():
            sys_command('chmod +x azurite_core_{0}'.format(test))

        logger.info('Creating boot-files')
        sys_command('make -C {0} XLEN={1}'.format(
            self.plugin_path + self.name + '_plugin/boot/', str(self.xlen)))
        shutil.copy(self.plugin_path+self.name+'_plugin/boot/boot.hex' , \
                self.sim_path+'/boot.mem')

        os.chdir(orig_path)
        if not os.path.isfile(self.sim_path + '/' + self.sim_cmd + '_' + test):
            logger.error(self.sim_cmd + '_' + test +
                         ' binary does not exist in ' + self.sim_path)
            raise SystemExit
        
    @dut_hookimpl
    def build(self):
        logger.info('Build Hook')
        make = makeUtil(makefilePath=os.path.join(self.work_dir,"Makefile." +\
            self.name))
        make.makeCommand = 'make -j1'
        self.make_file = os.path.join(self.work_dir, 'Makefile.' + self.name)
        self.test_names = []

        for test, attr in self.test_list.items():
            logger.debug('Creating Make Target for ' + str(test))
            abi = attr['mabi']
            arch = attr['march']
            isa = attr['isa']
            work_dir = attr['work_dir']
            link_args = attr['linker_args']
            link_file = attr['linker_file']
            cc = attr['cc']
            cc_args = attr['cc_args']
            asm_file = attr['asm_file']

            ch_cmd = 'cd {0} && '.format(work_dir)
            compile_cmd = '{0} {1} -march={2} -mabi={3} {4} {5} {6}'.format(\
                    cc, cc_args, arch, abi, link_args, link_file, asm_file)

            for x in attr['extra_compile']:
                compile_cmd += ' ' + x
            compile_cmd += ' '.join(map(' -D{0}'.format,
                                        attr['compile_macros']))
            compile_cmd += ' -o dut.elf && '
            sim_setup = 'ln -f -s ' + self.sim_path + '/azurite_core_{0} . && '.format(
                test)
            sim_setup += 'ln -f -s ' + self.sim_path + '/boot.mem . && '
            sim_setup += 'ln -f -s ' + self.sim_path + '/work . && '
            post_process_cmd = 'head -n -4 rtl.dump > dut.dump && rm -f rtl.dump'
            target_cmd = ch_cmd + compile_cmd + self.objdump_cmd +\
                    self.elf2hex_cmd + sim_setup + self.sim_cmd + '_' + test + ' ' + \
                    self.sim_args +' && '+ post_process_cmd
            make.add_target(target_cmd, test)
            self.test_names.append(test)

    @dut_hookimpl
    def run(self, module_dir):
        logger.info('Run Hook')
        logger.debug('Module dir: {0}'.format(module_dir))
        pytest_file = module_dir + '/azurite_verilator_plugin/gen_framework.py'
        logger.debug('Pytest file: {0}'.format(pytest_file))

        report_file_name = '{0}/{1}_{2}'.format(
            self.json_dir, self.name,
            datetime.datetime.now().strftime("%Y%m%d-%H%M"))

        pytest.main([
            pytest_file,
            '-x',  # Stop on first failure 
            '-n={0}'.format(self.jobs),
            '-k={0}'.format(self.filter),
            '--html={0}.html'.format(self.work_dir + '/reports/' + self.name),
            '--report-log={0}.json'.format(report_file_name),
            '--work_dir={0}'.format(self.work_dir),
            '--make_file={0}'.format(self.make_file),
            '--key_list={0}'.format(self.test_names),
            '--log-cli-level=DEBUG',
            '-o log_cli=true',
        ])

        if self.coverage:
            if os.path.exists(self.work_dir + '/final_coverage/rank'):
                shutil.rmtree(self.work_dir + '/final_coverage/rank')
            os.makedirs(self.work_dir + '/final_coverage/rank')

            if os.path.exists(self.work_dir + '/final_coverage/cov_html'):
                shutil.rmtree(self.work_dir + '/final_coverage/cov_html')
            os.makedirs(self.work_dir + '/final_coverage/cov_html')

            if os.path.exists(self.work_dir + '/final_coverage/rank_html'):
                shutil.rmtree(self.work_dir + '/final_coverage/rank_html')
            os.makedirs(self.work_dir + '/final_coverage/rank_html')

            merge_cmd = 'vcover merge -testassociated -outputstore ' + self.work_dir + 'final_coverage/' + ' -out ' + self.work_dir + '/final_coverage/' + 'merged_ucdb.ucdb'
            logger.info('Initiating Merging of coverage files')
            for test, attr in self.test_list.items():
                test_wd = attr['work_dir']
                os.makedirs(test_wd + '/coverage', exist_ok=True)
                shutil.move(test_wd + '/' + test + '.ucdb',
                            test_wd + '/coverage/' + test + '.ucdb')
                sys_command(
                    'vcover report -cvg -assert -code bcefst -details -html -htmldir '
                    + test_wd + '/coverage/ -verbose ' + test_wd +
                    '/coverage/' + test + '.ucdb' + '\n')
                merge_cmd += ' ' + test_wd + '/coverage/*.ucdb'
            with open(self.work_dir + '/merge.cmd', 'w') as f:
                f.write(merge_cmd + ' \n')
                f.write(
                    'vcover report -cvg -assert -code bcefst -details -html -htmldir '
                    + self.work_dir + '/cov_html -verbose ' + self.work_dir +
                    '/final_coverage/merged_ucdb.ucdb ' + '\n')
                f.write(
                    'vcover ranktest -64 -assertion -codeAll -cvg  -directive -rankfile '
                    + self.work_dir + '/rank/out.rank ' + self.work_dir +
                    '/final_coverage/merged_ucdb.ucdb ' + '\n')
                f.write('vcover report -html -rank ' + self.work_dir +
                        '/rank/out.rank ' + '-details=abcdefgpst -htmldir ' +
                        self.work_dir + '/rank_html ')
            sys_command('chmod +x {0}/merge.cmd'.format(self.work_dir))
            os.system('sh {0}/merge.cmd'.format(self.work_dir))
            logger.info(
                'Final coverage file is at: {0}'.format(self.work_dir +
                                                        '/final_coverage/'))
            logger.info('Final rank file is at: {0}'.format(self.work_dir +
                                                            '/rank_html'))
        return report_file_name

    @dut_hookimpl
    def post_run(self, test_dict, config):
        if config['river_core']['generator'] == 'uatg':
            if (config['uatg']['check_logs']).lower() == 'true':
                logger.info('Invoking uatg for checking logs')
                config_list = []
                config_list.append(config['uatg']['isa_config_yaml'])
                config_list.append(config['uatg']['core_config_yaml'])
                config_list.append(config['uatg']['custom_config_yaml'])
                config_list.append(config['uatg']['csr_grouping_yaml'])
                modules_dir = config['uatg']['modules_dir']
                work_dir = config['uatg']['work_dir']
                modules = config['uatg']['modules']
                check_log_command = (f"uatg validate --verbose debug --modules"
                                     f" {modules} --work_dir {work_dir}"
                                     f" --module_dir {modules_dir}"
                                     f" --configuration {config_list[0]}"
                                     f" --configuration {config_list[1]}"
                                     f" --configuration {config_list[2]}"
                                     f" --configuration {config_list[3]}")
                sys_command(check_log_command)
            else:
                logger.info('Not checking logs')

        if str_2_bool(config['river_core']['space_saver']):
            logger.debug("Going to remove stuff now")
            for test in test_dict:
                if test_dict[test]['result'] == 'Passed':
                    logger.debug("Removing extra files for Test: " + str(test))
                    work_dir = test_dict[test]['work_dir']
                    try:
                        os.remove(work_dir + '/app_log')
                        os.remove(work_dir + '/code.mem')
                        os.remove(work_dir + '/dut.disass')
                        os.remove(work_dir + '/dut.dump')
                        os.remove(work_dir + '/signature')
                        # Remove the HTML parts as well.
                        for coverage_file in glob.glob(work_dir +
                                                       '/coverage/*'):
                            if not coverage_file.endswith('.ucdb'):
                                if os.path.isfile(coverage_file):
                                    logger.debug(
                                        'File Detected here {0}'.format(
                                            coverage_file))
                                    os.remove(coverage_file)
                                elif os.path.isdir(coverage_file):
                                    logger.debug(
                                        'Folder Detected here {0}'.format(
                                            coverage_file))
                                    shutil.rmtree(coverage_file)
                    except:
                        logger.info(
                            "Something went wrong trying to remove the files")

    @dut_hookimpl
    def merge_db(self, db_files, output_db, config):

        # Add commands to run here :)
        # Create RANK folder
        os.makedirs(str(output_db) + '/final_rank/')
        os.makedirs(str(output_db) + '/final_html_rank/')
        os.makedirs(str(output_db) + '/cov_html/')
        logger.info('Initiating Merging of coverage files')
        merge_cmd = 'vcover merge -testassociated -outputstore ' + str(
            output_db) + '/final_coverage/' + ' -out ' + str(
                output_db) + '/final_coverage/merged_ucdb.ucdb'
        rank_cmd = 'vcover ranktest -64 -assertion -codeAll -cvg  -directive -rankfile ' + str(
            output_db) + '/final_rank/out.rank'

        for db_file in db_files:
            merge_cmd += ' ' + db_file
            rank_cmd += ' ' + db_file
        with open(str(output_db) + '/final_merge_vcover.cmd', 'w') as f:
            f.write(merge_cmd + ' \n')
            f.write(
                'vcover report -cvg -assert -code bcefst -details -html -htmldir '
                + str(output_db) + '/cov_html -verbose ' + str(output_db) +
                '/final_coverage/merged_ucdb.ucdb ' + '\n')
            f.write(rank_cmd + '\n')
            f.write('vcover report -html -rank ' + str(output_db) +
                    '/final_rank/out.rank ' + ' -details=abcdefgpst -htmldir ' +
                    str(output_db) + '/final_html_rank')
        orig_path = os.getcwd()
        os.chdir(output_db)
        sys_command('chmod +x {0}/final_merge_vcover.cmd'.format(output_db))
        sys_command('sh {0}/final_merge_vcover.cmd'.format(output_db))

        final_html = output_db + '/cov_html/index.html'
        final_rank_html = output_db + '/final_html_rank/rank.html'
        os.chdir(orig_path)
        return final_html, final_rank_html